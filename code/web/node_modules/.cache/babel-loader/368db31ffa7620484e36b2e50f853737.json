{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst log = require('npmlog');\n\nconst existsAsync = fs.exists || path.exists;\n\nconst versioning = require('./util/versioning.js');\n\nconst napi = require('./util/napi.js');\n\nconst makeDir = require('make-dir'); // for fetching binaries\n\n\nconst url = require('url');\n\nconst fetch = require('node-fetch');\n\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\n\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {// do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri); // Try getting version info from the currently running npm.\n\n  const envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  let agent;\n\n  if (proxyUrl) {\n    //                             1              2          3\n    const m = proxyUrl.match(/^(?:(https?:)\\/\\/)?([^:]+)(?::(\\d{1,4}))?\\/?$/);\n\n    if (m) {\n      const ProxyAgent = require(m[1] === 'https:' ? 'https-proxy-agent' : 'http-proxy-agent');\n\n      const protocol = m[1] === 'https:' ? 'https:' : 'http:';\n      const host = m[2];\n      const port = +(m[3] || (protocol === 'https:' ? 443 : 80));\n      const agentOpts = {\n        host,\n        port,\n        protocol\n      };\n      agent = new ProxyAgent(agentOpts);\n      log.http('download', 'proxy agent configured using: \"%o\"', agentOpts);\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  const options = url.parse(sanitized);\n  options.agent = agent;\n  fetch(options).then(res => {\n    if (!res.ok) {\n      throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n    }\n\n    const dataStream = res.body;\n    return new Promise((resolve, reject) => {\n      let extractions = 0;\n\n      const countExtractions = entry => {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', e => {\n        reject(e);\n      });\n      dataStream.on('end', () => {\n        resolve(`extracted file count: ${extractions}`);\n      });\n      dataStream.on('error', e => {\n        reject(e);\n      });\n    });\n  }).then(text => {\n    log.info(text);\n    callback();\n  }).catch(e => {\n    log.error(`install ${e.message}`);\n    callback(e);\n  });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n\n  log.info('Found local file to extract from ' + from); // extract helpers\n\n  let extractCount = 0;\n\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n\n  function afterExtract(err) {\n    if (err) return callback(err);\n\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n} //\n// install\n//\n\n\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true'; // but allow override from npm\n\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n\n    let opts;\n\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, found => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(err => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/gtanaka/OneDrive/college/2020-2021spring/csci3308/group/taskit/code/node_modules/@mapbox/node-pre-gyp/lib/install.js"],"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","makeDir","url","fetch","tar","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","place_binary","uri","targetDir","opts","callback","http","envVersionInfo","process","env","npm_config_user_agent","sanitized","replace","requestOpts","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","agent","m","match","ProxyAgent","protocol","host","port","agentOpts","warn","options","then","res","ok","Error","status","statusText","dataStream","body","Promise","resolve","reject","extractions","countExtractions","entry","info","pipe","extract","on","text","catch","error","message","to","onentry","cwd","strip","extract_from_local","from","existsSync","extractCount","afterExtract","err","createReadStream","do_build","gyp","argv","args","concat","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","statusCode","undefined","runtime","target","versions","node","node_abi","libc","hosted_tarball","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","fileName","startsWith","slice","after_place"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst makeDir = require('make-dir');\n// for fetching binaries\nconst url = require('url');\nconst fetch = require('node-fetch');\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\n\n\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  const envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n  let agent;\n  if (proxyUrl) {\n    //                             1              2          3\n    const m = proxyUrl.match(/^(?:(https?:)\\/\\/)?([^:]+)(?::(\\d{1,4}))?\\/?$/);\n    if (m) {\n      const ProxyAgent = require(m[1] === 'https:' ? 'https-proxy-agent' : 'http-proxy-agent');\n      const protocol = m[1] === 'https:' ? 'https:' : 'http:';\n      const host = m[2];\n      const port = +(m[3] || (protocol === 'https:' ? 443 : 80));\n      const agentOpts = { host, port, protocol };\n      agent = new ProxyAgent(agentOpts);\n      log.http('download', 'proxy agent configured using: \"%o\"', agentOpts);\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  const options = url.parse(sanitized);\n  options.agent = agent;\n\n  fetch(options)\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n      }\n      const dataStream = res.body;\n\n      return new Promise((resolve, reject) => {\n        let extractions = 0;\n        const countExtractions = (entry) => {\n          extractions += 1;\n          log.info('install', 'unpacking %s', entry.path);\n        };\n\n        dataStream.pipe(extract(targetDir, countExtractions))\n          .on('error', (e) => {\n            reject(e);\n          });\n        dataStream.on('end', () => {\n          resolve(`extracted file count: ${extractions}`);\n        });\n        dataStream.on('error', (e) => {\n          reject(e);\n        });\n      });\n    })\n    .then((text) => {\n      log.info(text);\n      callback();\n    })\n    .catch((e) => {\n      log.error(`install ${e.message}`);\n      callback(e);\n    });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  let extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))\n    .on('close', afterExtract)\n    .on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({ name: 'build', args: args });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    let opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, (found) => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch((err) => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}